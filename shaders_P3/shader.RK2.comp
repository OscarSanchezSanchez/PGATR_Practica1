#version 430 compatibility
#extension GL_ARB_compute_shader: enable
#extension GL_ARB_shader_storage_buffer_object: enable

layout (std140, binding=4) buffer Pos
{
	vec4 Positions[ ];
};

layout (std140, binding=5) buffer Vel
{
	vec4 Velocities[ ];
};

layout (std140, binding=6) buffer Old
{
	vec4 oldPositions[ ];
};

layout (std140, binding=8) buffer spawnPos
{
	vec4 spawnPositions[ ];
};

layout (std140, binding=10) buffer spawnVel
{
	vec4 spawnVels[ ];
};

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

const float dt = 0.001;
float G = 6.674 * pow(10, -11);
float M1 = 10000000000.0;
float M2 = 10000000000.0;
const float deathTime = 1;
//const vec3 atractor = vec3(2.0, 0.0, 0.0);
uniform vec3 atractor;

uint gid = gl_GlobalInvocationID.x;

vec3 x0;
vec3 v0;

void main()
{
	vec3 x = Positions[gid].xyz;
	float lifetime = Positions[gid].w;
	vec3 v = Velocities[gid].xyz;
	if (lifetime < 0)
	{
		Positions[gid] = spawnPositions[gid];
		Velocities[gid] = spawnVels[gid];
	}
	else{
		x0 = x;
		v0 = v;

		float d = distance(x, vec3(0.0f));
		vec3 acelGrav = -G * M1 * (1 / (d * d * d)) * x;

		float d2 = distance(x, atractor);
		vec3 acelGrav2 = -G * M2 * (1 / (d2 * d2 * d2)) * (x - atractor);

		vec3 vp = v + 0.5*dt*acelGrav + 0.5*dt*acelGrav2;
		vec3 xp = x + 0.5 * dt * vp;

		d = distance(xp, vec3(0.0f));
		acelGrav = -G * M1 * (1 / (d * d * d)) * xp;

		d2 = distance(xp, atractor);
		acelGrav2 = -G * M2 * (1 / (d2 * d2 * d2)) * (xp - atractor);

		xp = x0 + vp*dt;
		vp = v0 + acelGrav*dt + acelGrav2*dt;

		lifetime -= deathTime;
		Positions[gid] = vec4(xp, lifetime);
		Velocities[gid].xyz = vp;
	}
}