#version 430 compatibility
#extension GL_ARB_compute_shader: enable
#extension GL_ARB_shader_storage_buffer_object: enable

layout (std140, binding=4) buffer Pos
{
	vec4 Positions[ ];
};

layout (std140, binding=5) buffer Vel
{
	vec4 Velocities[ ];
};

layout (std140, binding=6) buffer Old
{
	vec4 oldPositions[ ];
};

layout (std140, binding=7) buffer Col
{
	vec4 Colors[ ];
};

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

bool sortDecreasing = true;
uint gid = gl_GlobalInvocationID.x;
uniform uint stage;
uniform uint subStage;


void bitonicSort() 
{
    uint threadId = gl_GlobalInvocationID.x;
    
    uint distanceBetweenPairs = uint(pow(2, stage - subStage));
    uint blockWidth = 2 * distanceBetweenPairs;
    
    uint leftId = (threadId % distanceBetweenPairs) + (threadId / distanceBetweenPairs) * blockWidth;
    uint rightId = leftId + distanceBetweenPairs;

    vec4 leftElementPos = Positions[leftId];
    vec4 rightElementPos = Positions[rightId];

    vec4 leftElementVel = Velocities[leftId];
    vec4 rightElementVel = Velocities[rightId];

    vec4 leftElementOldpos = oldPositions[leftId];
    vec4 rightElementOldpos = oldPositions[rightId];

    vec4 leftElementColor = Colors[leftId];
    vec4 rightElementColor = Colors[rightId];
    
    uint sameDirectionBlockWidth = uint(pow(2, stage));

    if((gid/sameDirectionBlockWidth) % 2 == 1)
    {
        sortDecreasing = !sortDecreasing;
    }

    //aux vectors
    vec4 greaterPos;
    vec4 lesserPos;
    vec4 greaterVel;
    vec4 lesserVel;
    vec4 greaterOldpos;
    vec4 lesserOldpos;
    vec4 greaterColor;
    vec4 lesserColor;

    if(leftElementPos.z > rightElementPos.z) 
    {
        greaterPos = leftElementPos;
        lesserPos = rightElementPos;

        greaterVel = leftElementVel;
        lesserVel = rightElementVel;

        greaterOldpos = leftElementOldpos;
        lesserOldpos = rightElementOldpos;

        greaterColor = leftElementColor;
        lesserColor = rightElementColor;
    } 
    else 
    {
        greaterPos = rightElementPos;
        lesserPos = leftElementPos;

        greaterVel = rightElementVel;
        lesserVel = leftElementVel;

        greaterOldpos = rightElementOldpos;
        lesserOldpos = leftElementOldpos;

        greaterColor = rightElementColor;
        lesserColor = leftElementColor;
    }
    if(!sortDecreasing) 
    {
        Positions[leftId] = lesserPos;
        Positions[rightId] = greaterPos;

        Velocities[leftId] = lesserVel;
        Velocities[rightId] = greaterVel;

        oldPositions[leftId] = lesserOldpos;
        oldPositions[rightId] = greaterOldpos;

        Colors[leftId] = lesserColor;
        Colors[rightId] = greaterColor;
    } 
    else 
    {
        Positions[leftId] = greaterPos;
        Positions[rightId] = lesserPos;

        Velocities[leftId] = greaterVel;
        Velocities[rightId] = lesserVel;

        oldPositions[leftId] = greaterOldpos;
        oldPositions[rightId] = lesserOldpos;

        Colors[leftId] = greaterColor;
        Colors[rightId] = lesserColor;
    }
}


void main()
{
    //Colors[gid].xyz = vec3(0.0, 0.5, 0.0);
    bitonicSort();
}